# 架构总览

`ThinkPHP`支持传统的`MVC`（Model-View-Controller）模式以及流行的`MVVM`（Model-View-ViewModel）模式的应用开发，下面的一些概念有必要做下了解，可能在后面的内容中经常会被提及。
## 入口文件
用户请求的PHP文件，负责处理请求（注意，不一定是HTTP请求）的生命周期，入口文件位于`public`目录下面，最常见的入口文件就是`index.php`，`8.0`支持多应用多入口，你可以给每个应用增加入口文件，例如给后台应用单独设置的一个入口文件`admin.php`。
如果开启自动多应用的话，一般只需要一个入口文件`index.php`。
## 应用
`8.0`版本提供了对多应用的良好支持，每个应用是一个`app`目录的子目录（或者指定的`composer`库），每个应用具有独立的路由、配置，以及MVC相关文件，这些应用可以公用框架核心以及扩展。而且可以支持`composer`应用加载。
## 容器
ThinkPHP使用（对象）容器统一管理对象实例及依赖注入。
容器类的工作由`think\Container`类完成，但大多数情况下我们都是通过应用类（`think\App`类）或是`app`助手函数来完成容器操作，容器中所有的对象实例都可以通过容器标识单例调用，你可以给容器中的对象实例绑定一个对象标识，如果没有绑定则使用类名作为容器标识。
## 系统服务
系统服务的概念是指在执行框架的某些组件或者功能的时候需要依赖的一些基础服务，服务类通常可以继承系统的`think\Service`类，但并不强制。
你可以在系统服务中注册一个对象到容器，或者对某些对象进行相关的依赖注入。由于系统服务的执行优先级问题，可以确保相关组件在执行的时候已经完成相关依赖注入。
## 路由
路由是用于规划（一般同时也会进行URL简化）请求的访问地址，在访问地址和实际操作方法之间建立一个路由规则 => 路由地址的映射关系。
ThinkPHP并非强制使用路由，如果没有定义路由，则可以直接使用“控制器/操作”的方式访问，如果定义了路由，则该路由对应的路由地址就被不能直接访问了。一旦开启强制路由参数，则必须为每个请求定义路由（包括首页）。
使用路由有一定的性能损失，但随之也更加安全，因为每个路由都有自己的生效条件，如果不满足条件的请求是被过滤的。你远比你在控制器的操作中进行各种判断要实用的多。
其实路由的作用远非URL规范这么简单，还可以实现验证、权限、参数绑定及响应设置等功能。
## 控制器
每个应用下面拥有独立的类库及配置文件，一个应用下面有多个控制器负责响应请求，而每个控制器其实就是一个独立的控制器类。
控制器主要负责请求的接收，并调用相关的模型处理，并最终通过视图输出。严格来说，控制器不应该过多的介入业务逻辑处理。
> 事实上，控制器是可以被跳过的，通过路由我们可以直接把请求调度到某个模型或者其他的类进行处理。
`ThinkPHP`的控制器类比较灵活，可以无需继承任何基础类库。
一个典型的`Index`控制器类（单应用模式）如下：
```php

    <?php
    namespace app\controller;
    
    class Index 
    {
        public function index()
        {
            return 'hello,thinkphp!';
        }
    }
    

```
> 一般建议继承一个基础的控制器，方便扩展。系统默认提供了一个`app\BaseController`控制器类。
## 操作
一个控制器包含多个操作（方法），操作方法是一个URL访问的最小单元。
下面是一个典型的`Index`控制器的操作方法定义，包含了两个操作方法：
```php

    <?php
    namespace app\controller;
    
    class Index 
    {
        public function index()
        {
            return 'index';
        }
        
        public function hello(string $name)
        {
            return 'Hello,'.$name;
        }
    }
    

```
操作方法可以不使用任何参数，如果定义了一个非可选参数，并且不是对象类型，则该参数必须通过用户请求传入，如果是URL请求，则通常是通过当前的请求传入，操作方法的参数支持依赖注入。
## 模型
模型类通常完成实际的业务逻辑和数据封装，并返回和格式无关的数据。
> 模型类并不一定要访问数据库，而且在ThinkPHP的架构设计中，只有进行实际的数据库查询操作的时候，才会进行数据库的连接，是真正的惰性连接。
ThinkPHP的模型层支持多层设计，你可以对模型层进行更细化的设计和分工，例如把模型层分为逻辑层/服务层/事件层等等。
模型类通常需要继承`think\Model`类，一个典型的`User`模型器类如下：
```php

    <?php
    namespace app\model;
    
    use think\Model;
    
    class User extends Model
    {
    }
    

```
## 视图
控制器调用模型类后，返回的数据通过视图组装成不同格式的输出。视图根据不同的需求，来决定调用模板引擎进行内容解析后输出还是直接输出。
视图通常会有一系列的模板文件对应不同的控制器和操作方法，并且支持动态设置模板目录。
## 模板引擎
模板文件中可以使用一些特殊的模板标签，这些标签的解析通常由模板引擎负责实现。
新版不再内置`think-template`模板引擎，如果需要使用ThinkPHP官方模板引擎，需要单独安装`think-view`模板引擎驱动扩展。
## 驱动
系统很多的组件都采用驱动式设计，从而可以更灵活的扩展，驱动类的位置默认是放入核心类库目录下面，也可以重新定义驱动类库的命名空间而改变驱动的文件位置。
> `8.0`版本的驱动采用`Composer`的方式安装和管理。
## 中间件
中间件主要用于拦截或过滤应用的`HTTP`请求，并进行必要的业务处理。
> 新版部分核心功能使用中间件处理，你可以灵活关闭。包括Session功能、请求缓存和多语言功能。
## 事件
可以在应用中使用事件机制的特性来扩展功能。
此外数据库操作和模型操作在完成数据操作的回调机制，也使用了事件机制。
## 助手函数
系统为一些常用的操作提供了助手函数支持。使用助手函数和性能并无直接影响，只是某些时候无法享受IDE自动提醒的便利，但是否使用助手函数看项目自身规范，在应用的公共函数文件中也可以对系统提供的助手函数进行重写。
